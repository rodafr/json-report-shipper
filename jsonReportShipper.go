package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"os"
	"path"
	"path/filepath"
	"strings"
	"time"

	"github.com/getgauge/common"
	"github.com/rodafr/json-report-shipper/gauge_messages"
	"github.com/rodafr/json-report-shipper/logger"
)

const (
	defaultReportsDir           = "reports"
	gaugeReportsDirEnvName      = "gauge_reports_dir" // directory where reports are generated by plugins
	overwriteReportsEnvProperty = "overwrite_reports"
	jsonReportFile              = "result.json"
	jsonReport                  = "json-report-shipper"
	setupAction                 = "setup"
	executionAction             = "execution"
	gaugePortEnv                = "plugin_connection_port"
	pluginActionEnv             = "json-report-shipper_action"
	timeFormat                  = "2006-01-02 15.04.05"
	reportApiUrlEnv             = "grepo_url"
	reportApiUserNameEnv        = "grepo_api_user"
	reportApiPasswordEnv        = "grepo_api_pass"
)

var projectRoot string

type nameGenerator interface {
	randomName() string
}

type timeStampedNameGenerator struct {
}

func (T timeStampedNameGenerator) randomName() string {
	return time.Now().Format(timeFormat)
}

func findProjectRoot() {
	projectRoot = os.Getenv(common.GaugeProjectRootEnv)
	if projectRoot == "" {
		logger.Fatalf("Environment variable '%s' is not set. \n", common.GaugeProjectRootEnv)
	}
}

func addDefaultPropertiesToProject() {
	defaultPropertiesFile := getDefaultPropertiesFile()

	reportsDirProperty := &(common.Property{
		Comment:      "The path to the gauge reports directory. Should be either relative to the project directory or an absolute path",
		Name:         gaugeReportsDirEnvName,
		DefaultValue: defaultReportsDir})

	overwriteReportProperty := &(common.Property{
		Comment:      "Set as false if gauge reports should not be overwritten on each execution. A new time-stamped directory will be created on each execution.",
		Name:         overwriteReportsEnvProperty,
		DefaultValue: "true"})

	reportApiUrlProperty := &(common.Property{
		Comment:      "URL to API endpoint, /reports will be added",
		Name:         reportApiUrlEnv,
		DefaultValue: "http://127.0.0.1:8080/",
	})

	if !common.FileExists(defaultPropertiesFile) {
		logger.Infof("Failed to setup json report plugin shipper in project. Default properties file does not exist at %s. \n", defaultPropertiesFile)
		return
	}
	if err := common.AppendProperties(defaultPropertiesFile, reportsDirProperty, overwriteReportProperty, reportApiUrlProperty); err != nil {
		logger.Infof("Failed to setup json report shipper plugin in project: %s \n", err)
		return
	}
	logger.Info("Successfully added configurations for json-report-shipper to env/default/default.properties")
}

func createReport(suiteResult *gauge_messages.SuiteExecutionResult) {
	jsonContents := generateJSONFileContents(suiteResult)
	reportDir, err := createJSONReport(createReportsDirectory(), jsonContents, getNameGen())
	if err != nil {
		logger.Fatalf("Report generation failed: %s \n", err)
	} else {
		logger.Infof("Successfully generated json-report to => %s\n", reportDir)
	}
	shipReport(jsonContents)
}

func shipReport(jsonContents []byte) int {
	reportApiUrl := os.Getenv(reportApiUrlEnv)
	reportApiUserName := os.Getenv(reportApiUserNameEnv)
	reportApiPassword := os.Getenv(reportApiPasswordEnv)
	data := bytes.NewReader(jsonContents)

	if reportApiUserName == "" {
		logger.Warnf("[WARNING] Report API username not set")
	}
	if reportApiPassword == "" {
		logger.Warnf("[WARNING] Report API password not set")
	}

	u, err := url.Parse(reportApiUrl)
	if err != nil {
		logger.Fatalf("[FATAL] Invalid report API URL: %v", err)
	}

	u.Path = path.Join(u.Path, "api/reports")

	logger.Infof("Received JSON content, shipping to %v\n", u.String())

	client := &http.Client{}
	request, err := http.NewRequest("POST", u.String(), data)
	if err != nil {
		logger.Debugf(err.Error())
	}

	request.SetBasicAuth(reportApiUserName, reportApiPassword)

	response, err := client.Do(request)
	if err != nil {
		logger.Fatalf("[WARNING] Failed to connect to API: " + err.Error())
	}

	defer response.Body.Close()

	if response.StatusCode != http.StatusCreated {
		logger.Warnf("[WARNING] HTTP status code received was not 201: %v\n", response.Status)
	} else {
		logger.Infof("Success: HTTP status code received from API was: %v\n", response.Status)
	}
	return response.StatusCode

}

func generateJSONFileContents(protoSuiteExeResult *gauge_messages.SuiteExecutionResult) []byte {
	var buffer bytes.Buffer
	suiteRes := toSuiteResult(protoSuiteExeResult.GetSuiteResult())
	buffer.WriteString(fmt.Sprintf("%s", marshal(suiteRes)))
	return buffer.Bytes()
}

func marshal(item interface{}) []byte {
	marshalledResult, err := json.MarshalIndent(item, "", "\t")
	if err != nil {
		logger.Fatalf("Failed to convert to json :%s\n", err)
	}
	return marshalledResult
}

func createJSONReport(reportsDir string, jsonContents []byte, nameGen nameGenerator) (string, error) {
	var currentReportDir string
	if nameGen != nil {
		currentReportDir = filepath.Join(reportsDir, jsonReport, nameGen.randomName())
	} else {
		currentReportDir = filepath.Join(reportsDir, jsonReport)
	}
	createDirectory(currentReportDir)
	return currentReportDir, writeResultJSONFile(currentReportDir, jsonContents)
}

func writeResultJSONFile(reportDir string, jsonContents []byte) error {
	resultJsPath := filepath.Join(reportDir, jsonReportFile)
	err := ioutil.WriteFile(resultJsPath, jsonContents, common.NewFilePermissions)
	if err != nil {
		return fmt.Errorf("failed to copy file: %s %s", jsonReportFile, err.Error())
	}
	return nil
}

func getNameGen() nameGenerator {
	var nameGen nameGenerator
	if shouldOverwriteReports() {
		nameGen = nil
	} else {
		nameGen = timeStampedNameGenerator{}
	}
	return nameGen
}

func getDefaultPropertiesFile() string {
	return filepath.Join(projectRoot, "env", "default", "default.properties")
}

func shouldOverwriteReports() bool {
	envValue := os.Getenv(overwriteReportsEnvProperty)
	if strings.ToLower(envValue) == "true" {
		return true
	}
	return false
}

func createReportsDirectory() string {
	reportsDir, err := filepath.Abs(os.Getenv(gaugeReportsDirEnvName))
	if reportsDir == "" || err != nil {
		reportsDir = defaultReportsDir
	}
	createDirectory(reportsDir)
	return reportsDir
}

func createDirectory(dir string) {
	if common.DirExists(dir) {
		return
	}
	if err := os.MkdirAll(dir, common.NewDirectoryPermissions); err != nil {
		logger.Fatalf("Failed to create directory %s: %s\n", defaultReportsDir, err)
	}
}
